import crypto from 'crypto'\nimport type { Location } from '@/types'\nimport type { RegisteredCamera } from '@/types/camera'\nimport type { UserRole } from '@/types/premium/subscription'\n\n// =============================================================================\n// LOCATION PRIVACY MANAGEMENT\n// =============================================================================\n\nexport interface LocationPrivacySettings {\n  exactLocationAccess: UserRole[] // Who can see exact locations\n  fuzzyRadius: number // Radius for location obfuscation in meters\n  minimumDistance: number // Minimum distance between obfuscated locations\n  preserveRelativePositions: boolean // Maintain relative positioning in fuzzy locations\n}\n\nexport interface FuzzyLocation {\n  originalLocation: Location\n  displayLocation: Location\n  privacyRadius: number\n  obfuscationMethod: 'circular' | 'grid' | 'polygonal'\n  timestamp: Date\n}\n\nexport class LocationPrivacyManager {\n  private readonly DEFAULT_SETTINGS: LocationPrivacySettings = {\n    exactLocationAccess: ['police', 'insurance', 'admin'],\n    fuzzyRadius: 25, // 25 meter radius = 50 meter diameter\n    minimumDistance: 10, // Minimum 10 meters between fuzzy points\n    preserveRelativePositions: true\n  }\n\n  /**\n   * Create privacy-protected display location for community view\n   */\n  createFuzzyLocation(\n    exactLocation: Location, \n    privacySettings: Partial<LocationPrivacySettings> = {},\n    seed?: string\n  ): FuzzyLocation {\n    const settings = { ...this.DEFAULT_SETTINGS, ...privacySettings }\n    \n    // Use deterministic randomization if seed provided (for consistent fuzzy locations)\n    const random = seed ? this.seededRandom(seed) : Math.random\n    \n    // Generate random offset within privacy radius\n    const angle = random() * 2 * Math.PI\n    const distance = random() * settings.fuzzyRadius\n    \n    // Convert to lat/lng offset\n    const latOffset = (distance * Math.cos(angle)) / 111320 // 1 degree lat â‰ˆ 111320 meters\n    const lngOffset = (distance * Math.sin(angle)) / (111320 * Math.cos(exactLocation.lat * Math.PI / 180))\n    \n    const displayLocation: Location = {\n      lat: exactLocation.lat + latOffset,\n      lng: exactLocation.lng + lngOffset\n    }\n\n    return {\n      originalLocation: exactLocation,\n      displayLocation,\n      privacyRadius: settings.fuzzyRadius,\n      obfuscationMethod: 'circular',\n      timestamp: new Date()\n    }\n  }\n\n  /**\n   * Create grid-based location obfuscation for consistent positioning\n   */\n  createGridBasedFuzzyLocation(\n    exactLocation: Location,\n    gridSize: number = 50 // Grid cell size in meters\n  ): FuzzyLocation {\n    // Snap to grid center for consistent fuzzy locations\n    const gridLat = Math.floor(exactLocation.lat * 111320 / gridSize) * gridSize / 111320\n    const gridLng = Math.floor(exactLocation.lng * (111320 * Math.cos(exactLocation.lat * Math.PI / 180)) / gridSize) * gridSize / (111320 * Math.cos(exactLocation.lat * Math.PI / 180))\n    \n    // Add center offset to grid cell\n    const displayLocation: Location = {\n      lat: gridLat + (gridSize / 2) / 111320,\n      lng: gridLng + (gridSize / 2) / (111320 * Math.cos(exactLocation.lat * Math.PI / 180))\n    }\n\n    return {\n      originalLocation: exactLocation,\n      displayLocation,\n      privacyRadius: gridSize / 2,\n      obfuscationMethod: 'grid',\n      timestamp: new Date()\n    }\n  }\n\n  /**\n   * Get appropriate location based on user role and privacy settings\n   */\n  getLocationForUser(\n    camera: RegisteredCamera,\n    userRole: UserRole,\n    privacySettings?: LocationPrivacySettings\n  ): Location {\n    const settings = privacySettings || this.DEFAULT_SETTINGS\n    \n    // Camera owner always sees exact location\n    if (camera.userId === this.getCurrentUserId()) {\n      return camera.location\n    }\n    \n    // Check if user role has access to exact locations\n    if (settings.exactLocationAccess.includes(userRole)) {\n      return camera.location\n    }\n    \n    // Return fuzzy location for community users\n    return camera.displayLocation\n  }\n\n  /**\n   * Batch process cameras for community display\n   */\n  applyCommunityPrivacy(\n    cameras: RegisteredCamera[],\n    privacySettings?: Partial<LocationPrivacySettings>\n  ): RegisteredCamera[] {\n    const settings = { ...this.DEFAULT_SETTINGS, ...privacySettings }\n    \n    return cameras.map(camera => {\n      // If camera already has display location, use it\n      if (camera.displayLocation) {\n        return camera\n      }\n      \n      // Generate consistent fuzzy location using camera ID as seed\n      const fuzzyLocation = this.createFuzzyLocation(\n        camera.location,\n        settings,\n        camera.id\n      )\n      \n      return {\n        ...camera,\n        displayLocation: fuzzyLocation.displayLocation\n      }\n    })\n  }\n\n  /**\n   * Verify location privacy is maintained\n   */\n  verifyLocationPrivacy(\n    exactLocation: Location,\n    displayLocation: Location,\n    expectedRadius: number\n  ): {\n    isPrivacyMaintained: boolean\n    actualDistance: number\n    privacyScore: number // 0-1, higher is better privacy\n  } {\n    const distance = this.calculateDistance(exactLocation, displayLocation)\n    const isPrivacyMaintained = distance <= expectedRadius\n    \n    // Privacy score: closer to center = lower privacy\n    const privacyScore = Math.min(distance / expectedRadius, 1)\n    \n    return {\n      isPrivacyMaintained,\n      actualDistance: distance,\n      privacyScore\n    }\n  }\n\n  /**\n   * Calculate distance between two points in meters\n   */\n  private calculateDistance(point1: Location, point2: Location): number {\n    const R = 6371000 // Earth's radius in meters\n    const lat1Rad = (point1.lat * Math.PI) / 180\n    const lat2Rad = (point2.lat * Math.PI) / 180\n    const deltaLatRad = ((point2.lat - point1.lat) * Math.PI) / 180\n    const deltaLngRad = ((point2.lng - point1.lng) * Math.PI) / 180\n\n    const a = Math.sin(deltaLatRad / 2) * Math.sin(deltaLatRad / 2) +\n              Math.cos(lat1Rad) * Math.cos(lat2Rad) *\n              Math.sin(deltaLngRad / 2) * Math.sin(deltaLngRad / 2)\n    \n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))\n    \n    return R * c\n  }\n\n  /**\n   * Seeded random number generator for consistent results\n   */\n  private seededRandom(seed: string): () => number {\n    let hash = 0\n    for (let i = 0; i < seed.length; i++) {\n      const char = seed.charCodeAt(i)\n      hash = ((hash << 5) - hash) + char\n      hash = hash & hash // Convert to 32-bit integer\n    }\n    \n    return () => {\n      hash = (hash * 9301 + 49297) % 233280\n      return hash / 233280\n    }\n  }\n\n  /**\n   * Get current user ID (mock implementation)\n   */\n  private getCurrentUserId(): string {\n    // In real implementation, get from auth context\n    return 'current-user-id'\n  }\n}\n\n// =============================================================================\n// USER ANONYMIZATION\n// =============================================================================\n\nexport interface AnonymousUser {\n  originalUserId: string\n  anonymousId: string\n  createdAt: Date\n  context: 'evidence_submission' | 'incident_report' | 'legal_proceedings'\n  retentionPeriod: number // days\n}\n\nexport class UserAnonymizationManager {\n  private readonly SALT = process.env.NEXT_PUBLIC_ANONYMIZATION_SALT || 'default-anonymization-salt'\n  \n  /**\n   * Generate anonymous ID for user while maintaining consistency\n   */\n  generateAnonymousId(\n    userId: string, \n    context: AnonymousUser['context'],\n    additionalSalt?: string\n  ): string {\n    const fullSalt = this.SALT + (additionalSalt || '')\n    const hash = crypto.createHash('sha256')\n    hash.update(userId + fullSalt + context)\n    \n    const anonymousId = hash.digest('hex').substring(0, 16).toUpperCase()\n    \n    // Add context prefix for identification\n    const prefixes = {\n      evidence_submission: 'EVD',\n      incident_report: 'INC', \n      legal_proceedings: 'LEG'\n    }\n    \n    return `${prefixes[context]}-${anonymousId}`\n  }\n\n  /**\n   * Create anonymous user record for legal proceedings\n   */\n  createAnonymousUser(\n    userId: string,\n    context: AnonymousUser['context'],\n    retentionDays: number = 2555 // ~7 years default\n  ): AnonymousUser {\n    return {\n      originalUserId: userId,\n      anonymousId: this.generateAnonymousId(userId, context),\n      createdAt: new Date(),\n      context,\n      retentionPeriod: retentionDays\n    }\n  }\n\n  /**\n   * Verify anonymous ID belongs to user (for reward payments etc.)\n   */\n  verifyAnonymousId(userId: string, anonymousId: string, context: AnonymousUser['context']): boolean {\n    const expectedAnonymousId = this.generateAnonymousId(userId, context)\n    return expectedAnonymousId === anonymousId\n  }\n\n  /**\n   * Generate court witness reference that protects identity\n   */\n  generateCourtReference(userId: string, caseId: string): {\n    witnessReference: string\n    courtId: string\n    verificationCode: string\n  } {\n    const witnessReference = this.generateAnonymousId(userId, 'legal_proceedings', caseId)\n    \n    // Generate court ID for legal identification\n    const courtHash = crypto.createHash('sha256')\n    courtHash.update(userId + caseId + 'court-reference')\n    const courtId = 'WITNESS-' + courtHash.digest('hex').substring(0, 8).toUpperCase()\n    \n    // Generate verification code for court use\n    const verifyHash = crypto.createHash('sha256')\n    verifyHash.update(userId + caseId + new Date().toDateString())\n    const verificationCode = verifyHash.digest('hex').substring(0, 12).toUpperCase()\n    \n    return {\n      witnessReference,\n      courtId,\n      verificationCode\n    }\n  }\n}\n\n// =============================================================================\n// DATA RETENTION MANAGEMENT\n// =============================================================================\n\nexport interface RetentionPolicy {\n  dataType: 'incident_reports' | 'evidence_files' | 'user_data' | 'payment_records' | 'audit_logs'\n  retentionPeriod: number // days\n  automaticDeletion: boolean\n  legalHoldExemption: boolean // Can be held longer for legal reasons\n  deletionMethod: 'soft_delete' | 'hard_delete' | 'anonymize'\n}\n\nexport class DataRetentionManager {\n  private readonly RETENTION_POLICIES: RetentionPolicy[] = [\n    {\n      dataType: 'incident_reports',\n      retentionPeriod: 2555, // 7 years\n      automaticDeletion: true,\n      legalHoldExemption: true,\n      deletionMethod: 'soft_delete'\n    },\n    {\n      dataType: 'evidence_files',\n      retentionPeriod: 2555, // 7 years\n      automaticDeletion: false, // Manual review required\n      legalHoldExemption: true,\n      deletionMethod: 'hard_delete'\n    },\n    {\n      dataType: 'user_data',\n      retentionPeriod: 1095, // 3 years\n      automaticDeletion: true,\n      legalHoldExemption: false,\n      deletionMethod: 'anonymize'\n    },\n    {\n      dataType: 'payment_records',\n      retentionPeriod: 2190, // 6 years (financial regulations)\n      automaticDeletion: true,\n      legalHoldExemption: true,\n      deletionMethod: 'soft_delete'\n    },\n    {\n      dataType: 'audit_logs',\n      retentionPeriod: 3650, // 10 years\n      automaticDeletion: false,\n      legalHoldExemption: true,\n      deletionMethod: 'soft_delete'\n    }\n  ]\n\n  /**\n   * Get retention policy for data type\n   */\n  getRetentionPolicy(dataType: RetentionPolicy['dataType']): RetentionPolicy | undefined {\n    return this.RETENTION_POLICIES.find(policy => policy.dataType === dataType)\n  }\n\n  /**\n   * Check if data should be deleted based on retention policy\n   */\n  shouldDeleteData(\n    dataType: RetentionPolicy['dataType'],\n    createdAt: Date,\n    hasLegalHold: boolean = false\n  ): {\n    shouldDelete: boolean\n    reason: string\n    daysOverdue?: number\n  } {\n    const policy = this.getRetentionPolicy(dataType)\n    if (!policy) {\n      return {\n        shouldDelete: false,\n        reason: 'No retention policy found for data type'\n      }\n    }\n\n    const daysSinceCreation = Math.floor((Date.now() - createdAt.getTime()) / (1000 * 60 * 60 * 24))\n    const isExpired = daysSinceCreation > policy.retentionPeriod\n    \n    if (!isExpired) {\n      return {\n        shouldDelete: false,\n        reason: 'Data within retention period'\n      }\n    }\n\n    if (hasLegalHold && policy.legalHoldExemption) {\n      return {\n        shouldDelete: false,\n        reason: 'Legal hold prevents deletion despite expiration'\n      }\n    }\n\n    const daysOverdue = daysSinceCreation - policy.retentionPeriod\n    \n    return {\n      shouldDelete: policy.automaticDeletion,\n      reason: policy.automaticDeletion \n        ? `Automatic deletion required - ${daysOverdue} days overdue`\n        : `Manual review required for deletion - ${daysOverdue} days overdue`,\n      daysOverdue\n    }\n  }\n\n  /**\n   * Generate GDPR-compliant deletion report\n   */\n  generateDeletionReport(\n    deletedItems: {\n      id: string\n      dataType: RetentionPolicy['dataType']\n      deletedAt: Date\n      deletionMethod: RetentionPolicy['deletionMethod']\n      reason: string\n    }[]\n  ): string {\n    const report = {\n      reportId: `DEL-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      generatedAt: new Date().toISOString(),\n      totalItemsDeleted: deletedItems.length,\n      deletionSummary: deletedItems.reduce((acc, item) => {\n        acc[item.dataType] = (acc[item.dataType] || 0) + 1\n        return acc\n      }, {} as Record<string, number>),\n      deletedItems: deletedItems.map(item => ({\n        id: item.id,\n        dataType: item.dataType,\n        deletedAt: item.deletedAt.toISOString(),\n        method: item.deletionMethod,\n        reason: item.reason\n      })),\n      compliance: {\n        gdprCompliant: true,\n        legalBasisForRetention: 'Data Protection Act 2018, Schedule 2, Part 1',\n        dataSubjectRights: 'Right to erasure exercised automatically per retention policy',\n        auditTrail: 'Complete audit trail maintained per regulatory requirements'\n      }\n    }\n\n    return JSON.stringify(report, null, 2)\n  }\n}\n\n// =============================================================================\n// GDPR CONSENT MANAGEMENT\n// =============================================================================\n\nexport interface ConsentRecord {\n  userId: string\n  consentType: 'evidence_sharing' | 'data_processing' | 'marketing' | 'analytics'\n  consentGiven: boolean\n  consentDate: Date\n  withdrawalDate?: Date\n  legalBasis: string\n  version: string // Terms version\n  ipAddress?: string\n  userAgent?: string\n}\n\nexport class ConsentManager {\n  /**\n   * Record user consent\n   */\n  recordConsent(\n    userId: string,\n    consentType: ConsentRecord['consentType'],\n    consentGiven: boolean,\n    legalBasis: string,\n    version: string,\n    metadata?: {\n      ipAddress?: string\n      userAgent?: string\n    }\n  ): ConsentRecord {\n    return {\n      userId,\n      consentType,\n      consentGiven,\n      consentDate: new Date(),\n      legalBasis,\n      version,\n      ipAddress: metadata?.ipAddress,\n      userAgent: metadata?.userAgent\n    }\n  }\n\n  /**\n   * Check if user has valid consent for specific processing\n   */\n  hasValidConsent(\n    userId: string,\n    consentType: ConsentRecord['consentType'],\n    currentVersion: string\n  ): {\n    hasConsent: boolean\n    requiresUpdate: boolean\n    reason: string\n  } {\n    // In real implementation, query from database\n    // Mock response for demonstration\n    return {\n      hasConsent: true,\n      requiresUpdate: false,\n      reason: 'Valid consent on record for current terms version'\n    }\n  }\n\n  /**\n   * Generate consent withdrawal confirmation\n   */\n  generateWithdrawalConfirmation(\n    userId: string,\n    consentType: ConsentRecord['consentType'],\n    withdrawalDate: Date\n  ): string {\n    const anonymousId = crypto.createHash('sha256')\n      .update(userId + 'withdrawal-confirmation')\n      .digest('hex')\n      .substring(0, 16)\n      .toUpperCase()\n\n    return `\nCONSENT WITHDRAWAL CONFIRMATION\n===============================\n\nConfirmation ID: CWD-${anonymousId}\nWithdrawal Date: ${withdrawalDate.toISOString()}\nConsent Type: ${consentType.replace('_', ' ').toUpperCase()}\n\nYour consent has been withdrawn and no further processing\nwill occur under this consent basis. Data will be deleted\nor anonymized according to our retention policy.\n\nFor questions: privacy@neighbourhoodwatchplus.com\n    `.trim()\n  }\n}\n\nexport {\n  LocationPrivacyManager,\n  UserAnonymizationManager,\n  DataRetentionManager,\n  ConsentManager\n}\n