import { \n  collection, \n  doc, \n  addDoc, \n  updateDoc, \n  deleteDoc, \n  getDocs, \n  getDoc,\n  query, \n  where, \n  orderBy, \n  limit,\n  Timestamp,\n  writeBatch,\n  onSnapshot\n} from 'firebase/firestore'\nimport { db } from '@/lib/firebase'\nimport type { \n  UserSubscription, \n  CommunityIncident, \n  EvidenceRequest, \n  EvidenceMatch, \n  TokenReward, \n  UserWallet, \n  ChainOfCustody,\n  UserRole \n} from '@/types/premium/subscription'\nimport type { RegisteredCamera } from '@/types/camera'\nimport { EvidenceMatchingEngine, type MatchingCriteria } from './evidence-matching'\nimport { ChainOfCustodyManager } from './chain-of-custody'\nimport { LocationPrivacyManager } from './privacy-manager'\n\n// =============================================================================\n// FIRESTORE COLLECTIONS\n// =============================================================================\n\nexport const PREMIUM_COLLECTIONS = {\n  userSubscriptions: 'userSubscriptions',\n  communityIncidents: 'communityIncidents', \n  evidenceRequests: 'evidenceRequests',\n  evidenceMatches: 'evidenceMatches',\n  tokenRewards: 'tokenRewards',\n  userWallets: 'userWallets',\n  chainOfCustody: 'chainOfCustody',\n  auditLogs: 'auditLogs',\n  anonymousUsers: 'anonymousUsers'\n} as const\n\n// =============================================================================\n// SUBSCRIPTION MANAGEMENT\n// =============================================================================\n\nexport class SubscriptionService {\n  /**\n   * Create new user subscription\n   */\n  static async createSubscription(subscription: Omit<UserSubscription, 'createdAt' | 'updatedAt'>): Promise<string> {\n    const subscriptionData = {\n      ...subscription,\n      createdAt: Timestamp.now(),\n      updatedAt: Timestamp.now()\n    }\n    \n    const docRef = await addDoc(collection(db, PREMIUM_COLLECTIONS.userSubscriptions), subscriptionData)\n    \n    // Update user profile with subscription info\n    await this.updateUserProfile(subscription.userId, {\n      role: subscription.role,\n      subscription: {\n        tier: subscription.tier.name,\n        status: subscription.status\n      }\n    })\n    \n    return docRef.id\n  }\n\n  /**\n   * Get user subscription\n   */\n  static async getUserSubscription(userId: string): Promise<UserSubscription | null> {\n    const q = query(\n      collection(db, PREMIUM_COLLECTIONS.userSubscriptions),\n      where('userId', '==', userId),\n      where('status', 'in', ['active', 'trial']),\n      limit(1)\n    )\n    \n    const snapshot = await getDocs(q)\n    if (snapshot.empty) return null\n    \n    const doc = snapshot.docs[0]\n    return { id: doc.id, ...doc.data() } as UserSubscription\n  }\n\n  /**\n   * Update subscription usage\n   */\n  static async updateUsage(userId: string, requestsUsed: number, amountSpent: number): Promise<void> {\n    const subscription = await this.getUserSubscription(userId)\n    if (!subscription) throw new Error('No active subscription found')\n    \n    const updatedUsage = {\n      monthlyRequests: subscription.usage.monthlyRequests + requestsUsed,\n      totalSpent: subscription.usage.totalSpent + amountSpent,\n      requestsRemaining: Math.max(0, subscription.usage.requestsRemaining - requestsUsed)\n    }\n    \n    await updateDoc(doc(db, PREMIUM_COLLECTIONS.userSubscriptions, subscription.id!), {\n      usage: updatedUsage,\n      updatedAt: Timestamp.now()\n    })\n  }\n\n  /**\n   * Check if user can make evidence request\n   */\n  static async canMakeRequest(userId: string): Promise<{\n    canRequest: boolean\n    reason?: string\n    requestsRemaining?: number\n  }> {\n    const subscription = await this.getUserSubscription(userId)\n    \n    if (!subscription) {\n      return { canRequest: false, reason: 'No active subscription' }\n    }\n    \n    if (subscription.status !== 'active' && subscription.status !== 'trial') {\n      return { canRequest: false, reason: 'Subscription not active' }\n    }\n    \n    if (subscription.usage.requestsRemaining <= 0) {\n      return { \n        canRequest: false, \n        reason: 'Monthly request limit reached',\n        requestsRemaining: 0\n      }\n    }\n    \n    return { \n      canRequest: true, \n      requestsRemaining: subscription.usage.requestsRemaining \n    }\n  }\n\n  private static async updateUserProfile(userId: string, updates: any): Promise<void> {\n    // Update the existing user profile with subscription info\n    await updateDoc(doc(db, 'users', userId), {\n      ...updates,\n      lastUpdated: Timestamp.now()\n    })\n  }\n}\n\n// =============================================================================\n// INCIDENT REPORTING SERVICE\n// =============================================================================\n\nexport class IncidentReportingService {\n  /**\n   * Create community incident with privacy protection\n   */\n  static async createCommunityIncident(\n    incident: Omit<CommunityIncident, 'id' | 'reportedAt' | 'updatedAt'>\n  ): Promise<string> {\n    // Apply location privacy if needed\n    const privacyManager = new LocationPrivacyManager()\n    let displayLocation = incident.displayLocation\n    \n    if (incident.privacy.anonymousReporting) {\n      const fuzzyLocation = privacyManager.createFuzzyLocation(incident.location)\n      displayLocation = fuzzyLocation.displayLocation\n    }\n    \n    const incidentData = {\n      ...incident,\n      displayLocation,\n      reportedAt: Timestamp.now(),\n      updatedAt: Timestamp.now()\n    }\n    \n    const docRef = await addDoc(collection(db, PREMIUM_COLLECTIONS.communityIncidents), incidentData)\n    \n    // Log the incident creation\n    await this.logAuditEvent('incident_created', {\n      incidentId: docRef.id,\n      reporterId: incident.reporterId,\n      type: incident.type,\n      location: incident.displayLocation // Use display location for audit\n    })\n    \n    return docRef.id\n  }\n\n  /**\n   * Get incidents visible to user role\n   */\n  static async getIncidentsForRole(\n    userRole: UserRole,\n    location?: { lat: number; lng: number; radius: number }\n  ): Promise<CommunityIncident[]> {\n    let q = query(\n      collection(db, PREMIUM_COLLECTIONS.communityIncidents),\n      where('privacy.visibleTo', 'array-contains', userRole),\n      orderBy('reportedAt', 'desc'),\n      limit(50)\n    )\n    \n    const snapshot = await getDocs(q)\n    const incidents = snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    })) as CommunityIncident[]\n    \n    // Filter by location if specified\n    if (location) {\n      return incidents.filter(incident => {\n        const distance = this.calculateDistance(\n          incident.displayLocation,\n          { lat: location.lat, lng: location.lng }\n        )\n        return distance <= location.radius\n      })\n    }\n    \n    return incidents\n  }\n\n  private static calculateDistance(point1: { lat: number; lng: number }, point2: { lat: number; lng: number }): number {\n    const R = 6371000 // Earth's radius in meters\n    const lat1Rad = (point1.lat * Math.PI) / 180\n    const lat2Rad = (point2.lat * Math.PI) / 180\n    const deltaLatRad = ((point2.lat - point1.lat) * Math.PI) / 180\n    const deltaLngRad = ((point2.lng - point1.lng) * Math.PI) / 180\n\n    const a = Math.sin(deltaLatRad / 2) * Math.sin(deltaLatRad / 2) +\n              Math.cos(lat1Rad) * Math.cos(lat2Rad) *\n              Math.sin(deltaLngRad / 2) * Math.sin(deltaLngRad / 2)\n    \n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))\n    \n    return R * c\n  }\n\n  private static async logAuditEvent(eventType: string, details: any): Promise<void> {\n    await addDoc(collection(db, PREMIUM_COLLECTIONS.auditLogs), {\n      eventType,\n      details,\n      timestamp: Timestamp.now(),\n      id: `audit-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n    })\n  }\n}\n\n// =============================================================================\n// EVIDENCE REQUEST SERVICE\n// =============================================================================\n\nexport class EvidenceRequestService {\n  /**\n   * Create evidence request and find matching sources\n   */\n  static async createEvidenceRequest(\n    request: Omit<EvidenceRequest, 'id' | 'createdAt' | 'updatedAt' | 'matches'>,\n    availableCameras: RegisteredCamera[]\n  ): Promise<{\n    requestId: string\n    matches: EvidenceMatch[]\n    estimatedCost: number\n  }> {\n    // Check if user can make request\n    const canRequest = await SubscriptionService.canMakeRequest(request.requesterId)\n    if (!canRequest.canRequest) {\n      throw new Error(canRequest.reason || 'Cannot make request')\n    }\n    \n    // Create matching criteria\n    const criteria: MatchingCriteria = {\n      incident: {\n        location: request.incident.location,\n        timeWindow: {\n          start: request.incident.timeWindow.start.toDate(),\n          end: request.incident.timeWindow.end.toDate()\n        },\n        radius: request.incident.radius,\n        type: request.incident.type,\n        urgency: request.incident.urgency\n      },\n      targeting: request.targeting,\n      budget: request.budget\n    }\n    \n    // Find matching evidence sources\n    const matchingEngine = new EvidenceMatchingEngine()\n    const matches = await matchingEngine.findPotentialSources(criteria, availableCameras)\n    \n    // Calculate estimated cost\n    const estimatedCost = matches.reduce((total, match) => total + match.estimatedReward, 0)\n    \n    // Create the evidence request\n    const requestData = {\n      ...request,\n      matches: [], // Will be populated separately\n      createdAt: Timestamp.now(),\n      updatedAt: Timestamp.now()\n    }\n    \n    const requestDocRef = await addDoc(collection(db, PREMIUM_COLLECTIONS.evidenceRequests), requestData)\n    const requestId = requestDocRef.id\n    \n    // Create evidence matches\n    const batch = writeBatch(db)\n    const matchIds: string[] = []\n    \n    for (const match of matches) {\n      const matchData = {\n        ...match,\n        requestId,\n        createdAt: Timestamp.now(),\n        updatedAt: Timestamp.now()\n      }\n      \n      const matchDocRef = doc(collection(db, PREMIUM_COLLECTIONS.evidenceMatches))\n      batch.set(matchDocRef, matchData)\n      matchIds.push(matchDocRef.id)\n    }\n    \n    await batch.commit()\n    \n    // Update request with match IDs\n    await updateDoc(requestDocRef, {\n      'matches': matchIds\n    })\n    \n    // Send notifications to camera owners\n    await this.notifyCameraOwners(matches, request)\n    \n    return {\n      requestId,\n      matches,\n      estimatedCost\n    }\n  }\n\n  /**\n   * Respond to evidence request\n   */\n  static async respondToRequest(\n    matchId: string,\n    response: {\n      status: 'accepted' | 'rejected' | 'no_footage'\n      message?: string\n      evidenceUrl?: string\n      evidenceMetadata?: any\n    }\n  ): Promise<void> {\n    const matchDoc = await getDoc(doc(db, PREMIUM_COLLECTIONS.evidenceMatches, matchId))\n    if (!matchDoc.exists()) {\n      throw new Error('Evidence match not found')\n    }\n    \n    const match = matchDoc.data() as EvidenceMatch\n    \n    // Create chain of custody if evidence provided\n    let chainOfCustodyId: string | undefined\n    if (response.evidenceUrl && response.status === 'accepted') {\n      const custodyManager = new ChainOfCustodyManager()\n      const chainOfCustody = await custodyManager.createChainOfCustody(\n        `evidence-${matchId}`,\n        {\n          id: matchId,\n          originalName: `evidence-${Date.now()}`,\n          fileSize: response.evidenceMetadata?.fileSize || 0,\n          mimeType: response.evidenceMetadata?.mimeType || 'video/mp4',\n          uploadedBy: match.ownerId,\n          uploadedAt: new Date(),\n          metadata: response.evidenceMetadata || {}\n        },\n        match.requestId\n      )\n      \n      // Store chain of custody\n      const custodyDocRef = await addDoc(collection(db, PREMIUM_COLLECTIONS.chainOfCustody), chainOfCustody)\n      chainOfCustodyId = custodyDocRef.id\n    }\n    \n    // Update the match with response\n    await updateDoc(doc(db, PREMIUM_COLLECTIONS.evidenceMatches, matchId), {\n      response: {\n        ...response,\n        respondedAt: Timestamp.now()\n      },\n      chainOfCustody: chainOfCustodyId,\n      updatedAt: Timestamp.now()\n    })\n    \n    // Create reward if evidence accepted\n    if (response.status === 'accepted' && response.evidenceUrl) {\n      await this.createTokenReward(match)\n    }\n  }\n\n  /**\n   * Get evidence requests for user\n   */\n  static async getRequestsForUser(\n    userId: string,\n    userRole: UserRole,\n    status?: EvidenceRequest['status']\n  ): Promise<EvidenceRequest[]> {\n    let q = query(\n      collection(db, PREMIUM_COLLECTIONS.evidenceRequests),\n      where('requesterId', '==', userId),\n      orderBy('createdAt', 'desc')\n    )\n    \n    if (status) {\n      q = query(q, where('status', '==', status))\n    }\n    \n    const snapshot = await getDocs(q)\n    return snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    })) as EvidenceRequest[]\n  }\n\n  private static async notifyCameraOwners(\n    matches: EvidenceMatch[],\n    request: Omit<EvidenceRequest, 'id' | 'createdAt' | 'updatedAt' | 'matches'>\n  ): Promise<void> {\n    // In real implementation, send push notifications, emails, etc.\n    console.log(`Sending notifications to ${matches.length} camera owners for request ${request.incident.type}`)\n    \n    // Could integrate with notification service here\n    for (const match of matches) {\n      // Send notification to match.ownerId\n      await this.sendNotification(match.ownerId, {\n        type: 'evidence_request',\n        title: 'New Evidence Request',\n        message: `Evidence requested for ${request.incident.type} incident`,\n        data: {\n          matchId: match.id,\n          reward: match.estimatedReward,\n          urgency: request.incident.urgency\n        }\n      })\n    }\n  }\n\n  private static async sendNotification(userId: string, notification: any): Promise<void> {\n    // Mock notification service - integrate with Firebase Cloud Messaging, email service, etc.\n    console.log(`Notification sent to ${userId}:`, notification)\n  }\n\n  private static async createTokenReward(match: EvidenceMatch): Promise<void> {\n    const reward: Omit<TokenReward, 'id'> = {\n      recipientId: match.ownerId,\n      evidenceMatchId: match.id!,\n      requestId: match.requestId,\n      amount: match.estimatedReward,\n      rewardType: 'evidence_provided',\n      paymentStatus: 'pending',\n      paymentMethod: 'platform_credit',\n      platformCommission: match.estimatedReward * 0.15, // 15% commission\n      netAmount: match.estimatedReward * 0.85,\n      createdAt: Timestamp.now(),\n      updatedAt: Timestamp.now()\n    }\n    \n    await addDoc(collection(db, PREMIUM_COLLECTIONS.tokenRewards), reward)\n    \n    // Update user wallet\n    await WalletService.addEarnings(match.ownerId, reward.netAmount)\n  }\n}\n\n// =============================================================================\n// WALLET SERVICE\n// =============================================================================\n\nexport class WalletService {\n  /**\n   * Get or create user wallet\n   */\n  static async getUserWallet(userId: string): Promise<UserWallet> {\n    const walletDoc = await getDoc(doc(db, PREMIUM_COLLECTIONS.userWallets, userId))\n    \n    if (walletDoc.exists()) {\n      return walletDoc.data() as UserWallet\n    }\n    \n    // Create new wallet\n    const newWallet: UserWallet = {\n      userId,\n      balance: 0,\n      pendingEarnings: 0,\n      totalEarned: 0,\n      totalWithdrawn: 0,\n      paymentPreferences: {\n        method: 'platform_credit',\n        minimumWithdrawal: 25,\n        autoWithdraw: false\n      },\n      transactions: [],\n      updatedAt: Timestamp.now()\n    }\n    \n    await updateDoc(doc(db, PREMIUM_COLLECTIONS.userWallets, userId), newWallet)\n    return newWallet\n  }\n\n  /**\n   * Add earnings to user wallet\n   */\n  static async addEarnings(userId: string, amount: number): Promise<void> {\n    const wallet = await this.getUserWallet(userId)\n    \n    const transaction = {\n      id: `txn-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      type: 'credit' as const,\n      amount,\n      description: 'Evidence reward received',\n      timestamp: Timestamp.now(),\n      status: 'completed' as const\n    }\n    \n    const updatedWallet = {\n      balance: wallet.balance + amount,\n      totalEarned: wallet.totalEarned + amount,\n      transactions: [...wallet.transactions, transaction],\n      updatedAt: Timestamp.now()\n    }\n    \n    await updateDoc(doc(db, PREMIUM_COLLECTIONS.userWallets, userId), updatedWallet)\n  }\n\n  /**\n   * Process withdrawal\n   */\n  static async processWithdrawal(\n    userId: string,\n    amount: number,\n    method: 'platform_credit' | 'bank_transfer' | 'paypal'\n  ): Promise<void> {\n    const wallet = await this.getUserWallet(userId)\n    \n    if (wallet.balance < amount) {\n      throw new Error('Insufficient balance')\n    }\n    \n    if (amount < wallet.paymentPreferences.minimumWithdrawal) {\n      throw new Error(`Minimum withdrawal is £${wallet.paymentPreferences.minimumWithdrawal}`)\n    }\n    \n    const transaction = {\n      id: `txn-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      type: 'withdrawal' as const,\n      amount,\n      description: `Withdrawal via ${method}`,\n      timestamp: Timestamp.now(),\n      status: 'pending' as const\n    }\n    \n    const updatedWallet = {\n      balance: wallet.balance - amount,\n      totalWithdrawn: wallet.totalWithdrawn + amount,\n      transactions: [...wallet.transactions, transaction],\n      updatedAt: Timestamp.now()\n    }\n    \n    await updateDoc(doc(db, PREMIUM_COLLECTIONS.userWallets, userId), updatedWallet)\n    \n    // Process payment via external service\n    await this.processExternalPayment(userId, amount, method, transaction.id)\n  }\n\n  private static async processExternalPayment(\n    userId: string,\n    amount: number,\n    method: string,\n    transactionId: string\n  ): Promise<void> {\n    // Integrate with payment processors (Stripe, PayPal, etc.)\n    console.log(`Processing ${method} payment of £${amount} for user ${userId}, transaction ${transactionId}`)\n    \n    // For demo purposes, simulate successful payment\n    setTimeout(async () => {\n      const wallet = await this.getUserWallet(userId)\n      const updatedTransactions = wallet.transactions.map(txn => \n        txn.id === transactionId ? { ...txn, status: 'completed' as const } : txn\n      )\n      \n      await updateDoc(doc(db, PREMIUM_COLLECTIONS.userWallets, userId), {\n        transactions: updatedTransactions,\n        updatedAt: Timestamp.now()\n      })\n    }, 5000) // Simulate 5-second processing time\n  }\n}\n\n// =============================================================================\n// REAL-TIME LISTENERS\n// =============================================================================\n\nexport class RealtimeService {\n  /**\n   * Listen to evidence requests for camera owner\n   */\n  static listenToEvidenceRequests(\n    cameraOwnerId: string,\n    callback: (matches: EvidenceMatch[]) => void\n  ): () => void {\n    const q = query(\n      collection(db, PREMIUM_COLLECTIONS.evidenceMatches),\n      where('ownerId', '==', cameraOwnerId),\n      where('response', '==', null),\n      orderBy('createdAt', 'desc')\n    )\n    \n    return onSnapshot(q, (snapshot) => {\n      const matches = snapshot.docs.map(doc => ({\n        id: doc.id,\n        ...doc.data()\n      })) as EvidenceMatch[]\n      \n      callback(matches)\n    })\n  }\n\n  /**\n   * Listen to user wallet updates\n   */\n  static listenToWallet(\n    userId: string,\n    callback: (wallet: UserWallet) => void\n  ): () => void {\n    return onSnapshot(doc(db, PREMIUM_COLLECTIONS.userWallets, userId), (doc) => {\n      if (doc.exists()) {\n        callback(doc.data() as UserWallet)\n      }\n    })\n  }\n\n  /**\n   * Listen to evidence request updates\n   */\n  static listenToRequestUpdates(\n    requestId: string,\n    callback: (request: EvidenceRequest) => void\n  ): () => void {\n    return onSnapshot(doc(db, PREMIUM_COLLECTIONS.evidenceRequests, requestId), (doc) => {\n      if (doc.exists()) {\n        callback({ id: doc.id, ...doc.data() } as EvidenceRequest)\n      }\n    })\n  }\n}\n\nexport {\n  SubscriptionService,\n  IncidentReportingService,\n  EvidenceRequestService,\n  WalletService,\n  RealtimeService\n}\n